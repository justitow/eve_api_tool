ramActivities
Contains the activity ID for different industry activites. Has the reactions ID type

activityID|activityName|iconNo|description|published
0|None||No activity|1
1|Manufacturing|18_02|Manufacturing|1
2|Researching Technology|33_02|Technological research|0
3|Researching Time Efficiency|33_02|Researching time efficiency|1
4|Researching Material Efficiency|33_02|Researching material efficiency|1
5|Copying|33_02|Copying|1
6|Duplicating||The process of creating an item, by studying an already existing item.|0
7|Reverse Engineering|33_02|The process of creating a blueprint from an item.|1
8|Invention|33_02|The process of creating a more advanced item based on an existing item|1
11|Reactions|18_02|The process of combining raw and intermediate materials to create advanced components|1


REACTIONS
activityID=11

SELECT * FROM INVTYPES WHERE INVTYPES.TYPEID IN (SELECT typeid FROM industryactivity where activityid=11); This gets the invtypes info for all reactions (not counting 'unrefined')

Maybe. Now I need to check the groups found with:  

SELECT * FROM invGroups WHERE UPPER(groupName) like '%REACTION%';

groupID|categoryID|groupName|iconID|useBasePrice
436|24|Simple Reaction|2665|1|0|0|0|1
484|24|Complex Reactions|2666|1|0|0|0|1
661|24|Simple Biochemical Reactions|2665|0|0|0|0|1
662|24|Complex Biochemical Reactions|2665|0|0|0|0|1
977|24|Hybrid Reactions||1|0|0|0|1

1888|9|Composite Reaction Formulas||1|0|0|0|1
1889|9|Polymer Reaction Formulas||1|0|0|0|1
1890|9|Biochemical Reaction Formulas||1|0|0|0|1

The category from the first part is 24, which means REACTION (is this now deprecated?)
The category from the second aprt is 9, which means BLUEPRINT

Assuming I'm not making boosters, I just need to look at 1888 and 1889
industryActivity is just the time for the reaction

Now I want to know about PI materials....I'll check group
PI Categories?

SELECT * FROM invCategories WHERE UPPER(categoryName) LIKE '%PLANET%';
categoryID|categoryName|iconID|published
41|Planetary Interaction||1
42|Planetary Resources||1
43|Planetary Commodities||1


industryActivity is the time it takes for blueprints to happen, and links the typeid of the reaction blueprint to the activity id

industryBlueprint is MaxProductionLimit - this is....?

SELECT typeID FROM invTypes WHERE groupID IN (1888, 1889, 1890);
SELECT typeID FROM industryActivity WHERE activityID=11;  **** I like this one better because industryActivity is way smaller


SELECT * FROM industryActivityProducts WHERE typeID IN (SELECT typeID FROM industryActivity WHERE activityID=11);

typeID|activityID|productTypeID|quantity
46186|11|33337|200
46187|11|32821|1
46188|11|32822|1
46189|11|32823|1
46190|11|32824|1
46191|11|32825|1
46192|11|32826|1
46193|11|32827|1
46194|11|32828|1
46195|11|32829|1
46196|11|29664|1
46197|11|29663|1
46198|11|29662|1
46199|11|29661|1
46200|11|29660|1
46201|11|29659|1
46202|11|33339|1
46203|11|33338|1
46204|11|16671|10000

What is this block about?
Making the urefined reaction thingy
Can either leave this out or include it
Might just allow it to exist.


SELECT * FROM industryActivityMaterials WHERE typeID IN (SELECT typeID FROM industryActivity WHERE activityID=11);

Everything seems to be within order


SELECT DISTINCT MATS.materialTypeID 
	FROM industryActivityMaterials MATS 
	WHERE MATS.typeID 
	IN
		(SELECT typeID 
		FROM industryActivity IACT 
		WHERE IACT.activityID=11) 
	ORDER BY MATS.materialTypeID ASC;

SELECT DISTINCT productTypeID FROM industryActivityProducts WHERE typeID IN(SELECT typeID FROM industryActivity WHERE activityID=11) ORDER BY productTypeID ASC;


SELECT typeID FROM industryActivityMaterials WHERE typeID IN(SELECT typeID FROM industryActivity WHERE activityID=11) AND materialTypeID in (SELECT DISTINCT productTypeID FROM industryActivityProducts WHERE typeID IN(SELECT typeID FROM industryActivity WHERE activityID=11))ORDER BY typeID ASC;
I also need to take into account that it is possible to use the subreactions instead of the material

Should I do this as a seperate entry in the thing? So like,
create row in database for both main and subreaction, and show source?
Make it recursive?

Each material will show a source
	Source will either be a station or a 

	Entry in table for each possible location?
	IF LOCATION=='CREATE'
	Time to make material on the table
	
Gather the buy price for materials
Gather the sell price for materials

SELECT DISTINCT productTypeID FROM industryActivityProducts WHERE productTypeID IN (SELECT materialTypeID FROM industryActivityMaterials WHERE materialtypeID IN(SELECT typeID FROM industryActivity WHERE activityID=11));
This is not working. For some reason, its putting the typeID for fuel block

SELECT DISTINCT mats.materialTypeID 
	FROM industryActivityMaterials mats 
	WHERE mats.materialTypeID IN 
		(SELECT prod.productTypeID 
		FROM industryActivityProducts prod 
		WHERE prod.TypeID IN 
			(SELECT inda.typeID 
			FROM industryActivity inda 
			WHERE inda.activityID=11)
		) ORDER BY mats.materialTypeID ASC;
		

SELECT DISTINCT prod.productTypeID 
	FROM industryActivityProducts prod 
	WHERE prod.productTypeID IN 
		(SELECT mats.materialTypeID 
		FROM industryActivityMaterials mats 
		WHERE mats.TypeID IN 
			(SELECT inda.typeID 
			FROM industryActivity inda 
			WHERE inda.activityID=11)
		) ORDER BY prod.ProductTypeID ASC;
		
This has way less resutls
Does not look correct
Maybe I can do an inner join?



THIS GETS ME ALL OF THE COMPOSITE REACTIONS PROBBALY?

SELECT invt.typeName, invt.typeid, invt.groupid 
	FROM 
		(SELECT DISTINCT prod.productTypeID 
		FROM industryActivityProducts prod
		WHERE prod.typeID IN 
			(SELECT inac.typeID 
				FROM industryActivity inac 
				WHERE inac.activityID=11)) all_products
	INNER JOIN
		(SELECT DISTINCT materialTypeID 
		FROM industryActivityMaterials 
		WHERE typeID IN
			(SELECT typeID 
				FROM industryActivity 
				WHERE activityID=11)) all_materials
		ON all_products.productTypeID=all_materials.materialTypeID
	JOIN invTypes invt
		ON invt.typeid=all_materials.materialTypeID
	WHERE invt.groupID != 712
	ORDER BY all_products.productTypeID ASC;
	
	
sqlite> select groupname from invgroups where groupid=428;
Intermediate Materials

I'm going to check with the rest of the materials now to check their groups
Or I'll check the products...?

SELECT DISTINCT MATS.materialTypeID, TYPE.typename, type.groupID 
	FROM industryActivityMaterials MATS 
	JOIN invTypes TYPE
		ON TYPE.typeID=MATS.materialTypeID
	WHERE 
		MATS.typeID IN
			(SELECT typeID 
			FROM industryActivity IACT 
			WHERE IACT.activityID=11)
		-- AND TYPE.groupID=428
	ORDER BY MATS.materialTypeID ASC;
	
16654|Titanium Chromide|428
16655|Crystallite Alloy|428
16656|Fernite Alloy|428
16657|Rolled Tungsten Alloy|428
16658|Silicon Diborite|428
16659|Carbon Polymers|428
16660|Ceramic Powder|428
16661|Sulfuric Acid|428
16662|Platinum Technite|428
16663|Caesarium Cadmide|428
16664|Solerium|428
16665|Hexite|428
16666|Hyperflurite|428
16667|Neo Mercurite|428
16668|Dysporite|428
16669|Ferrofluid|428
17769|Fluxed Condensates|428
17959|Vanadium Hafnite|428
17960|Prometium|428
33336|Thulium Hafnite|428
33337|Promethium Mercurite|428

This should be all of the materials that are subreactions themselves? (the GROUPID=428 ones)
	
Maybe filter out biochemical materials?
(groupID != 712)


SELECT COUNT() FROM (SELECT DISTINCT MATS.materialTypeID, TYPE.typename, type.groupID 
	FROM industryActivityMaterials MATS 
	JOIN invTypes TYPE
		ON TYPE.typeID=MATS.materialTypeID
	WHERE 
		MATS.typeID IN
			(SELECT typeID 
			FROM industryActivity IACT 
			WHERE IACT.activityID=11)
		 AND TYPE.groupID=428
	ORDER BY MATS.materialTypeID ASC);
	
	
SELECT COUNT() FROM (SELECT invt.typeName, invt.typeid, invt.groupid 
	FROM 
		(SELECT DISTINCT prod.productTypeID 
		FROM industryActivityProducts prod
		WHERE prod.typeID IN 
			(SELECT inac.typeID 
				FROM industryActivity inac 
				WHERE inac.activityID=11)) all_products
	INNER JOIN
		(SELECT DISTINCT materialTypeID 
		FROM industryActivityMaterials 
		WHERE typeID IN
			(SELECT typeID 
				FROM industryActivity 
				WHERE activityID=11)) all_materials
		ON all_products.productTypeID=all_materials.materialTypeID
	JOIN invTypes invt
		ON invt.typeid=all_materials.materialTypeID
	WHERE invt.groupID != 712
	ORDER BY all_products.productTypeID ASC);
	
Both counts produce result of 21, which means that they are both ways to see the materials that can be produced from reactions


SELECT invt.typeName, invt.typeid, invt.groupid 
	FROM 
		(SELECT DISTINCT prod.productTypeID 
		FROM industryActivityProducts prod
		WHERE prod.typeID IN 
			(SELECT inac.typeID 
				FROM industryActivity inac 
				WHERE inac.activityID=11)) all_products
	INNER JOIN
		(SELECT DISTINCT materialTypeID 
		FROM industryActivityMaterials 
		WHERE typeID IN
			(SELECT typeID 
				FROM industryActivity 
				WHERE activityID=11)) all_materials
		ON all_products.productTypeID=all_materials.materialTypeID
	JOIN invTypes invt
		ON invt.typeid=all_materials.materialTypeID
	--WHERE invt.groupID != 712
	ORDER BY all_products.productTypeID ASC;
	
This one seems like it is the best "future proof" one
Maybe I should create my own tables

CREATE TABLE ODB.reaction_materials AS 
	SELECT * 
	FROM industryActivityMaterials MATS
	WHERE MATS.typeID IN
		(SELECT IACT.typeID 
		FROM industryActivity IACT
		WHERE IACT.activityID=11);
		
CREATE TABLE ODB.reaction_products AS
	SELECT * 
	FROM industryActivityProducts PROD
	WHERE PROD.typeID IN 
		(SELECT INAC.typeID 
		FROM industryActivity INAC 
		WHERE INAC.activityID=11);
		
		
SELECT *
	FROM 
		(SELECT DISTINCT productTypeID 
		FROM ODB.reaction_products) products
	INNER JOIN
		(SELECT DISTINCT materialTypeID 
		FROM ODB.reaction_materials) materials
	ON products.productTypeID=materials.materialTypeID
	ORDER BY products.productTypeID ASC;
	
Now I'll make a table for the industryActivity, since I might as well at this point

CREATE TABLE ODB.reaction_activities AS
	SELECT * FROM industryActivity WHERE activityID=11;
	

In summary, at this point, I have:
	-table with reaction materials
	-table with reaction products
	-table with reaction activities

	
How am I going to store the price?
What data can I retrieve from the API?
How granular should I be looking at the data?


/markets/{region_id}/history/ 		--- List historical market statistics in a region
/markets/{region_id}/orders/ 		--- List orders in a region
/markets/{region_id}/types/ 		--- List type IDs relevant to a market
/markets/groups/ 					--- Get item groups
/markets/groups/{market_group_id}/	--- Get item group information
/markets/prices/					--- List market prices
/markets/structures/{structure_id}/	--- List orders in a structure


I will use 
/markets/{region_id}/history/ 		--- List historical market statistics in a region
/markets/{region_id}/orders/ 		--- List orders in a region

For Jita, at least, if I don't use the type_id, there are ~300 pages
There are 98 unique materials
		  94 unique products

What about the other markets? Probably similarish results?

How should I go about the data for the markets


SELECT regionID, solarSystemNAME from mapSolarSystems where solarsystemname IN ('Jita', 'Hek', 'Amarr', 'Dodixie');

regionID|solarSystemName
10000002|Jita
10000042|Hek
10000043|Amarr
10000032|Dodixie


So I need to create a table to store the values-

{
'duration': 90, 
'is_buy_order': False, 
'issued': <pyswagger.primitives._time.Datetime object at 0x0AD08AD0>, 
'location_id': 60003760, 
'min_volume': 1, 
'order_id': 5219840991, 
'price': 17490.6, 
'range': 'region', 
'system_id': 30000142, 
'type_id': 16657, 
'volume_remain': 60000, 
volume_total': 60000
}

I may want to also include the regionID

CREATE TABLE ODB.market_info(
duration INTEGER,
is_buy_order INTEGER,
issued DATETIME,
location_id INTEGER,
min_volume INTEGER,
order_id INTEGER,
price FLOAT,
range TEXT,
system_id INTEGER,
volumn_remain INTEGER,
volumn_total INTEGER,
region_id INTEGER
);


SELECT * FROM market_info WHERE type_id=16658 AND is_buy_order=1 ORDER BY price DESC;
Is correct when I verify against evemarketer
system_id can get a good idea of where I'm actually going to be selling

